#ifndef _PROTOTIPOS_H
#define _PROTOTIPOS_H

#include <stdlib.h>
#include <stdio.h>
#include <string.h> 

//struct global
typedef struct {
    int n; //Número de Cidades;
    char nomes[100][255];
    double matriz[100][100];
} matrizAdj; // Matriz de Adjacência;

//variavel estatica
extern matrizAdj matrizADJ;

int CadastroCidades(matrizAdj *matrizAdj);
int CadastroManual(matrizAdj *m);
int CarregarArquivo(matrizAdj *matrizAdj);

//exibir.c
void ExibirMatrizes(matrizAdj *matrizADJ, int N, double d[][N], int p[][N]);
void ExibirMatrizAdj(matrizAdj *m);
void ExibirMatrizD(int n, double matriz[n][n]);
void ExibirMatrizP(int n, int matriz[n][n]);

//salvar.c
void Salvar(matrizAdj *matrizAdj, int N, double d[][N], int p[][N]);
int SalvarDadosIniciais(matrizAdj *matrizAdj);
int SalvarResultados(int N, double d[][N], int p[][N]);

//floyd.c
void floydWarshall(matrizAdj *m, int N,double d[][N], int p[][N]);

//calcRota
void CalcularRota(const matrizAdj *m, int N, const double d[][N],const int p[][N]);
int ReconstruirCaminho(int N, int origem, int destino, const int p[][N], int path_out[]);

//cadastro.c
#define MAXCHAR 1000
int CadastroManual(matrizAdj *m){
  int n_cidades = m->n;
  do{
    system("cls");
    printf("\n ============ CADASTRO-MANUAL ============");
    printf("\n > Informe o Numero dos Municipios: ");
    scanf("%i", &n_cidades);
    
    printf(" > Nomes dos Municipios:\n");
    for (int i = 0; i < n_cidades; i++){
      printf("  %02d.", i + 1);
      scanf(" %[^\n]", m->nomes[i]);
    }

    printf(" > Distancia Entre dos Municipios:\n");

    for (int i = 0; i < n_cidades; i++){
      for (int j = i; j < n_cidades; j++){
        if (i == j){
          m->matriz[i][j] = 0;
        }else{
          printf("\n> De %s Para %s: ", m->nomes[i], m->nomes[j]);
          scanf("%lf", &m->matriz[i][j]);
          m->matriz[j][i] = m->matriz[i][j];
        }
      }
    }
    
    system("cls");
    printf("\n");
    
    //================================ Exbição =======================================
    
    
    printf("\n -> ==== MATRIZ CADASTRADA COM SUCESSO !! ====\n");

    ExibirMatrizAdj(m);

    int escolhas;
    printf("\n ==== Deseja Confirmar Valores? ====");
    printf("\n > [1] Confirmar");
    printf("\n > [2] Alterar");
    printf("\n > [0] Cancelar ");
    printf("\n ===================================");
    
    printf("\n -> Opcao: ");
    scanf("%i", &escolhas);

    system("cls");

    switch (escolhas){
    case 1:
      printf("\n* Valores Confirmados!");
      SalvarDadosIniciais(m);
      return 1;
      case 2:
      printf("\n* Alterar Valores!");
      break;
      case 0:
      printf("\n* Valores Cancelados!");
      return 0;
      break;
    }
    
  } while (1);
}
int CarregarArquivo(matrizAdj *matrizAdj){
  FILE *arquivo = NULL;
  
  do{
    system("cls");
    char origem[500];
    printf("\n ============ CADASTRO-MANUAL ============");
    printf("\n > Origem do arquivo: ");
    scanf(" %[^\n]", origem);

    arquivo = fopen(origem, "r");

    char linha[MAXCHAR];

    if (arquivo != NULL){

      // Amazena - Numero de cidades
      if (fgets(linha, MAXCHAR, arquivo) != NULL){
        matrizAdj->n = atoi(linha);
      }

      int n_cidades = matrizAdj->n;

      // Amazena - Nomes das cidades
      for (int i = 0; i < n_cidades; i++){
        if (fgets(linha, MAXCHAR, arquivo) != NULL){
          strcpy(matrizAdj->nomes[i], linha);
        }
      }

      // Amazena - Matriz de adjacentes
      for (int i = 0; i < n_cidades; i++){
        fgets(linha, MAXCHAR, arquivo);

        char *token = strtok(linha, ";");

        for (int j = 0; j < n_cidades; j++){
          matrizAdj->matriz[i][j] = atof(token);
          token = strtok(NULL, ";");
        }
      }
      //===================================================== EXIBIÇÃO =====================================================
    
      ExibirMatrizAdj(matrizAdj);
      fclose(arquivo);
      system("pause");
      // vai executar o algoritimo?

      return 1;
    }else{
      int escolhas;
      printf("\n ====== ARQUIVO INDISPONIVEL ======");
      printf("\n > [1] Tentar novamente");
      printf("\n > [0] Cancelar");
      printf("\n =================================");
      printf("\n > Escolha: ");
      scanf("%i", &escolhas);

      switch (escolhas){
      case 1:
        system("cls");

        break;
      case 0:
        system("cls");
        printf("\n* Saindo...\n");
        return 1;
      }
    }
  } while (1);
}
int CadastroCidades(matrizAdj *matrizAdj){
  int escolha;

    system("cls");
    printf("\n ========== CADASTRO-DE-CIDADES ==========");
    printf("\n > [1] Adicionar Manualmente");
    printf("\n > [2] Carregar Arquivo");
    printf("\n > [0] Voltar");
    printf("\n =========================================\n");
    printf(" -> Opcao: ");
    scanf("%i", &escolha);

    switch (escolha){
      case 1:
        escolha = CadastroManual(matrizAdj);
        break;
      case 2:
        escolha = CarregarArquivo(matrizAdj);
        break;
      case 0:
        break;

    default:
      printf("\n #ERRO: sua escolha é invalida, tente novamente...\n");
      system("pause");
      break;
    }
  return escolha;
}
//exibir.c
void ExibirMatrizes(matrizAdj *matrizADJ, int N, double d[][N], int p[][N]) {
    int escolha;

    do {
        system("cls");
        printf("\n =========== EXIBIR-MATRIZES ===========");
        printf("\n > [1] Matriz Adjacencias");
        printf("\n > [2] Matriz Distancias Minimas");
        printf("\n > [3] Matriz de Predecessores");
        printf("\n > [0] Voltar");
        printf("\n =======================================");
        printf("\n -> Opcao: "); 
        scanf("%d", &escolha);

        switch (escolha){
        case 1:
            ExibirMatrizAdj(matrizADJ);
        case 2:
            ExibirMatrizD(N,d);
            break;
        case 3:
            ExibirMatrizP(N,d);
            break;
        
        default:

            break;
        }

    } while (1);
}
void ExibirMatrizAdj(matrizAdj *m){
    int n_cidades = m->n; // m-> n (valor de n que está na matriz m, sendo n o n_cidades);
    // Exibição - Lista de nomes de cidades
    system("cls");
    printf("\n > LISTA-DE-CIDADES:\n"); 
    for (int i = 0; i < n_cidades; i++){
        printf(" %.02d. %s\n",i+1,m->nomes[i]);
    }

    // Exibição - Matriz de Adjacentes
    printf("\n > MATRIZ-DE-ADJACENTES:\n\n");
    for (int i = 0; i < n_cidades; i++){
        printf(" | ");
        for (int j = 0; j < n_cidades; j++){
            printf(" %7.2f ",m->matriz[i][j]);
            if(j < n_cidades - 1){
                printf("|");
            }
        }
        printf(" |\n");
    }
    printf("\n");
}
void ExibirMatrizD(int n, double matriz[n][n]){
    system("cls");
    printf("\n > MATRIZ-DE-DISTANCIAS-MINIMAS:\n\n");
    for (int i = 0; i < n; i++){
        printf(" | ");
        for (int j = 0; j < n; j++){
            printf(" %.2f ",matriz[i][j]);
            if(j < n - 1){
                printf("|");
            }
        }
        printf(" |\n");
    }
    printf("\n");
}
void ExibirMatrizP(int n, int matriz[n][n]){
    system("cls");
    printf("\n > MATRIZ-DE-PREDECESSORES:\n\n");
    for (int i = 0; i < n; i++){
        printf(" | ");
        for (int j = 0; j < n; j++){
            printf(" %i ",matriz[i][j]);
            if(j < n - 1){
                printf("|");
            }
        }
        printf(" |\n");
    }
    printf("\n");
}

//salvar.c
void Salvar(matrizAdj *matrizAdj, int N, double d[][N], int p[][N]) {
    int escolhas;
    do{
        system("cls");
        printf("\n ========= Que titulo? =========");
        printf("\n [1] Dados Iniciais");
        printf("\n [2] Dados Resultantes");
        printf("\n [0] Voltar");
        printf("\n =================================");
        printf("\n Opcao: ");
        scanf("%i", &escolhas);
        
        switch (escolhas){
        case 1:
            SalvarDadosIniciais(matrizAdj);
            break;
        case 2:
            SalvarResultados(N, d, p);
            break;
        case 0:
            
            return;
        
        default:
            printf("\n #ERRO: sua escolha é invalida, tente novamente...\n");
            system("pause");
            break;
        }

    }while(1);
        
}
int SalvarDadosIniciais(matrizAdj *matrizAdj){
    int escolhas;
    do{
        system("cls");
        printf("\n ==== SALVAR DADOS INICIAIS EM ARQUIVO? ====");
        printf("\n > [1] Sim > [0] Nao");
        printf("\n ===========================================");
        printf("\n Opcao: ");
        scanf("%i", &escolhas);

        if(escolhas == 1){
            // Arquivo de dados iniciais
            FILE *arquivo = fopen("Banco_de_Dados/cidades.txt", "w");

            if(arquivo != NULL){

                printf("\n** Arquivo 'cidades.txt' aberto com sucesso **\n");

                int n_cidades = matrizAdj->n;

                // Escreve no arquivo numero de cidades
                fprintf(arquivo, "%i\n", n_cidades);

                // Escreve no arquivo nomes de cidades
                for(int i = 0; i < n_cidades; i++){
                    fprintf(arquivo, "%s\n", matrizAdj->nomes[i]);
                }

                // Escreve no arquivo matriz adjacencias
                for(int i = 0; i < n_cidades; i++){
                    for(int j = 0; j < n_cidades; j++){
                        fprintf(arquivo, "%.2f",matrizAdj->matriz[i][j]);
                        if(j < n_cidades - 1){
                            fprintf(arquivo, ";");
                        }
                    }
                    if (i < n_cidades - 1){
                        fprintf(arquivo, "\n");
                    }
                }

                fclose(arquivo);
                printf("** Dados salvos com sucesso **\n");

            }else{
                printf(" #ERRO: ao abrir o arquivo 'cidades.txt'.\n");
            }
        } else {
            return 0;
        }
    }while(1);
}
int SalvarResultados(int N, double d[][N], int p[][N]){
    int escolhas;
    do{
        system("cls");
        printf("\n ====== SALVAR RESULTADOS EM ARQUIVO? =======");
        printf("\n > [1] Sim > [0] Nao");
        printf("\n ============================================");
        printf("\n Opcao: ");
        scanf("%i", &escolhas);

        if(escolhas == 1){
            // Arquivo de RESULTADOS
            FILE *arquivo = fopen("Banco_de_Dados/resultados.txt", "w"); 

            if(arquivo != NULL){

                printf("\n** Arquivo 'resultados.txt' aberto com sucesso **\n");

                // Escreve no arquivo numero de cidades
                fprintf(arquivo, "%i\n", N);

                // Escreve no arquivo distancias minimas
                for(int i = 0; i < N; i++){
                    for(int j = 0; j < N; j++){
                        fprintf(arquivo, "%.2f",d[i][j]);
                        if(j < N - 1){
                            fprintf(arquivo, ";");
                        }
                    }
                    if (i < N - 1){
                        fprintf(arquivo, "\n");
                    }
                }
                
                // Escreve no arquivo prodecessores
                for(int i = 0; i < N; i++){
                    for(int j = 0; j < N; j++){
                        fprintf(arquivo, "%.2f",p[i][j]);
                        if(j < N - 1){
                            fprintf(arquivo, ";");
                        }
                    }
                    if (i < N - 1){
                        fprintf(arquivo, "\n");
                    }
                }

                fclose(arquivo);
                printf("** Dados salvos com sucesso **\n");

            }else{
                printf(" #ERRO: ao abrir o arquivo 'resultados.txt'.\n");
            }
        } else {
            return 0;
        }
    }while(1);

}

//floyd.c
void floydWarshall(matrizAdj *m, int N,double d[][N], int p[][N]) {

    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            d[i][j] = m->matriz[i][j];
            if (i == j) {
                p[i][j] = -1;
            } else if (m->matriz[i][j] < 10000) p[i][j] = i;
            else p[i][j] = -1;
        }
    }

    for (int k = 0; k < N; k++) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if((d[i][k] + d[k][j]) < d[i][j]){
                    d[i][j] = d[i][k]+d[k][j];
                    p[i][j] = p[k][j];
                }
            }
        }
    }
}


//calcRota
// Reconstrói caminho origem->destino usando p.
// Retorna tamanho do caminho ou -1 se não existe.
int ReconstruirCaminho(int N, int origem, int destino, const int p[][N], int path_out[]){
    if (origem < 0 || origem >= N || destino < 0 || destino >= N) return -1;

    if (origem == destino) {
        path_out[0] = origem;
        return 1;
    }

    int stack[N];
    int top = 0;

    int atual = destino;
    stack[top++] = destino;

    while (atual != origem) {
        int pred = p[origem][atual];
        if (pred < 0) return -1; // sem caminho
        atual = pred;
        if (top >= N) return -1; // proteção
        stack[top++] = atual;
    }

    // inverter para obter origem -> ... -> destino
    int len = 0;
    for (int k = top - 1; k >= 0; k--) {
        path_out[len++] = stack[k];
    }
    return len;
}

// Lista cidades na ordem cadastrada, numeradas 1..N, pede índice e mostra a rota
void CalcularRota(const matrizAdj *m, int N, const double d[][N], const int p[][N]){
    system("cls");
    printf("\n =========== CALCULAR-ROTA ===========\n");
    printf(" Escolha pelo numero da cidade:\n\n");

    // Lista numerada (1..N) na ordem original
    for (int i = 0; i < N; i++) {
        printf(" %2d) %s\n", i + 1, m->nomes[i]);
    }

    int opOrigem, opDestino;
    printf("\n Origem (1..%d): ", N);
    if (scanf("%d", &opOrigem) != 1) { puts("Entrada invalida."); system("pause"); return; }

    printf(" Destino (1..%d): ", N);
    if (scanf("%d", &opDestino) != 1) { puts("Entrada invalida."); system("pause"); return; }

    // Validação
    if (opOrigem < 1 || opOrigem > N || opDestino < 1 || opDestino > N) {
        puts("\n !! Numero de cidade invalido !!");
        system("pause");
        return;
    }

    // Ajustar para índice 0-based
    int origem  = opOrigem  - 1;
    int destino = opDestino - 1;

    // Checar existência de caminho
    if (origem != destino && p[origem][destino] < 0) {
        printf("\n Nao existe caminho de '%s' para '%s'.\n",
               m->nomes[origem], m->nomes[destino]);
        system("pause");
        return;
    }

    int path[N];
    int len = ReconstruirCaminho(N, origem, destino, p, path);
    if (len < 0) {
        printf("\n Nao existe caminho de '%s' para '%s'.\n",
               m->nomes[origem], m->nomes[destino]);
        system("pause");
        return;
    }

    // Imprimir rota e distância
    printf("\n Rota: ");
    for (int k = 0; k < len; k++) {
        printf("%s", m->nomes[path[k]]);
        if (k < len - 1) printf(" -> ");
    }
    printf("\n Distancia total: %.2f\n", d[origem][destino]);

    system("pause");
}

#endif